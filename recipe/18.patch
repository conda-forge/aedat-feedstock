diff --git a/Cargo.toml b/Cargo.toml
index 414b5d5..7d2b2c0 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -12,8 +12,8 @@ crate-type = ["cdylib"]
 flatbuffers = "24.3.25"
 lz4 = "1.24.0"
 ndarray = "0.15.6"
-numpy = "0.21.0"
-pyo3 = {version = "0.21.2", features = ["extension-module"]}
+numpy = "0.22.1"
+pyo3 = {version = "0.22.0", features = ["extension-module"]}
 roxmltree = "0.20.0"
 zstd = "0.13.1"
 
diff --git a/src/lib.rs b/src/lib.rs
index bda8c12..80d1f9f 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -5,6 +5,7 @@ use numpy::convert::ToPyArray;
 use numpy::prelude::*;
 use numpy::Element;
 use pyo3::prelude::*;
+use pyo3::types::{PyAny, PyBytes, PyString};
 
 impl std::convert::From<aedat_core::ParseError> for pyo3::PyErr {
     fn from(error: aedat_core::ParseError) -> Self {
@@ -591,24 +592,31 @@ unsafe fn set_dtype_as_list_field(
 }
 
 fn python_path_to_string(
-    python: pyo3::prelude::Python,
-    path: &pyo3::Bound<'_, pyo3::types::PyAny>,
+    python: Python,
+    path: &PyAny,
 ) -> PyResult<String> {
-    if let Ok(result) = path.downcast::<pyo3::types::PyString>() {
-        return Ok(result.to_string());
+    if path.is_instance::<PyString>()? {
+        let py_string: &PyString = path.extract()?;
+        return Ok(py_string.to_str()?.to_string());
     }
-    if let Ok(result) = path.downcast::<pyo3::types::PyBytes>() {
-        return Ok(result.to_string());
+    if path.is_instance::<PyBytes>()? {
+        let py_bytes: &PyBytes = path.extract()?;
+        return Ok(String::from_utf8(py_bytes.as_bytes().to_vec())
+            .map_err(|e| PyErr::new::<pyo3::exceptions::PyValueError, _>(format!("{}", e)))?);
     }
-    let fspath_result = path.to_object(python).call_method0(python, "__fspath__")?;
-    {
-        let fspath_as_string: PyResult<&pyo3::types::PyString> = fspath_result.extract(python);
-        if let Ok(result) = fspath_as_string {
-            return Ok(result.to_string());
-        }
+    let fspath_result = path.call_method0("__fspath__")?;
+    if fspath_result.is_instance::<PyString>()? {
+        let py_string: &PyString = fspath_result.extract()?;
+        return Ok(py_string.to_str()?.to_string());
+    }
+    if fspath_result.is_instance::<PyBytes>()? {
+        let py_bytes: &PyBytes = fspath_result.extract()?;
+        return Ok(String::from_utf8(py_bytes.as_bytes().to_vec())
+            .map_err(|e| PyErr::new::<pyo3::exceptions::PyValueError, _>(format!("{}", e)))?);
     }
-    let fspath_as_bytes: &pyo3::types::PyBytes = fspath_result.extract(python)?;
-    Ok(fspath_as_bytes.to_string())
+    Err(PyErr::new::<pyo3::exceptions::PyTypeError, _>(
+        "Expected a string, bytes, or an object implementing __fspath__",
+    ))
 }
 
 #[pymodule]
